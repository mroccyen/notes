### 可靠性

![](E:\01-github\myprofile\notes\消息队列\RabbitMQ\images\lc.jpg)

- ①代表消息从生产者发送到Exchange
- ②代表消息从Exchange路由到Queue
- ③ 代表消息在Queue中存储
- ④ 代表消费者订阅Queue并消费消息

#### 确保消息被成功的发送到了Exchange

- 导致原因：网络问题或者broke的问题，导致生产者不知道是否消息成功发送到了exchange中

- 解决方法：

  第一种是**事务模式**

  ​	1、通过channel.txSelect方法开启事务

  ​	2、发送消息

  ​	3、出现异常或者其他原因后通过channel.txRollback进行回滚

​		第二种是**确认模式**

​		1、通过channel.confirmSelect设置通道为confirm模式

​		2、接收确认消息（Basic.Ack）

#### 确保消息被正确的路由到Queue

- 导致原因：路由键错误、队列不存在、队列名不正确
- 解决方法：
  -  使用mandatory参数和ReturnListener
  -  使用备份交换机（alternate-exchange），无法路由的消息会发送到这个交换机上 

#### 确保消息被正确的存储

- 导致原因：系统宕机、重启或关闭
- 解决方法：队列、交换机、消息都要进行持久化

#### 确保消息被成功投递到消费者

- 导致原因：消费者收到消息后出现异常，或者在处理过程中出现异常
- 解决方法：消费者订阅消息时指定autoAck为false

#### 番外篇

##### 消费者回调

 消费者处理消息之后，可以再发送一条消息给生产者，或者调用生产者地API，告知消息处理完毕 

##### 补偿机制

 对于一定时间没有响应地消息，可以设置一个定时重发地机制，但是要控制次数，比如最多重复三次，否则会造成消息堆积 

##### 消息幂等性

 服务端是没有这种控制的，只能在消费端控制 

##### 如何避免消息的重复消费？消息重复消费可能会有两个原因

1. 生产者的问题。环节①重复发送消息，比如在开启Confirm模式但未收到确认
2. 环节④出了问题，由于消费者未发送ACK或者其它原因，消息重复投递

对于重复发送的消息，可以对每一条消息生成一个唯一的业务id，通过日志或者建表来做重复控制。