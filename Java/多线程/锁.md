# 锁

## 锁分类


### 线程要不要锁住同步资源？

- 锁住：悲观锁，比如synchronized和Lock的实现类

- 不锁住：乐观锁，比如CAS算法

### 锁住同步资源失败，线程要不要阻塞？

#### 阻塞

#### 不阻塞

- 自旋锁
  - 优点：避免线程切换的开销
  - 缺点：占用处理器时间，自旋时间越长占用CPU资源越多
  - 自旋次数可以通过（默认是10次，可以使用-XX:PreBlockSpin来更改）设置
  - 自旋使用-XX:+UseSpinning参数来开启
  - 常见锁形式
    - TicketLock
    - CLHlock
    - MCSlock

##### 适应性自旋锁

- 自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

- 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间

- 如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源

### 多个线程竞争同步资源的流程细节有没有区别？

***以下都是针对synchronized的***

#### 各个锁状态下的对象头Mark Word分布

##### 无锁

- 锁标记位=01

- 是否偏向锁=0

- hashcode

- GC分代年龄

##### 偏向锁

- 锁标记位=01

- 是否偏向锁=1

- 偏向线程ID

- 偏向时间戳

##### 轻量级锁

- 锁标记位=00

- 指向栈中锁记录的指针

##### 重要级锁

- 锁标记位=10

- 指向互斥量（重量级锁）的指针

***大部分情况下锁状态只能升级不能降级***

#### 无锁

##### 概述

不锁住资源，多个线程只有一个能修改资源成功，其他资源会重试

#### 偏向锁

##### 概述

同一个线程执行同步资源时自动获取资源，降低获取锁的代价，强调是只有一个线程访问

对象头Mark Word（标记字段）中记录偏向的线程ID，后面直接检测线程ID来进入同步区域

##### 偏向锁获取过程

- 1、确认偏向锁标记位设置为1，锁标记位设置为01
- 2、标志位都正确的话，当前线程id与偏向线程id比较
  - 1、如果相等，进入同步代码
  - 2、如果不等，执行接下来的步骤
- 3、通过CAS竞争锁
  - 1、如果成功，设置偏向锁id为当前线程id，进入同步代码块
  - 2、如果失败，执行接下来的步骤

- 4、失败代表有竞争，暂停持有偏向锁的线程，这时如果偏向线程还活着，直接升级为轻量级锁

##### 偏向锁释放时机

遇到其他线程尝试竞争偏向锁时

##### 偏向锁释放流程

- 等待全局安全点（在这个时间点上没有字节码正在执行）

- 暂停拥有偏向锁的线程

- 判断锁对象是否处于被锁定状态

- 撤销偏向锁后恢复到未锁定或轻量级锁状态

通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态

#### 轻量级锁

##### 概述

多个线程竞争同步资源时，没有获取资源的线程自旋等待锁释放，不阻塞线程，这里强调的是两个线程

##### 加锁过程

- 1、将对象头中的Mark Word复制到线程栈帧的锁记录（Lock Record）中（官方称之为 Displaced Mark Word）

- 2、通过CAS将对象头的Mark Word更新为指向Lock Record的指针

- 3、将Lock Word里面的owner指针指向对象的Mark Word

- 4、如果成功，设置Mark Word中的锁标志位为00，这时就出于轻量级锁

- 5、如果失败，检查对象的Mark Word是否指向当前线程的栈帧，是直接进入同步块

##### 解锁过程

- 1、通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word

- 2、如果替换成功，整个同步过程就完成了

- 3、如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程

#### 重量级锁

##### 概述

多个线程同步资源时，没有获取资源的线程阻塞等待唤醒，这里强调的是三个及以上的线程

##### 实现

通过监视器来实现：monitor

### 多个线程竞争锁是要不要排队？

#### 排队

##### 公平锁

- 特点
  - 队列中的第一个线程能获取锁
  - 线程在队列中排队

- 优点
  - 等待锁的线程不会饿死始终会获取到锁

- 缺点
  - 除第一个线程外的线程都会阻塞，影响吞吐量
  - 唤醒阻塞线程的开销比非公平锁大

#### 先尝试插队，插队失败再排队

##### 非公平锁

- 特点

多个线程直接参与锁的竞争，获取不到才加入等待队列

- 优点

可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程

- 缺点

处于等待队列中的线程可能会饿死，或者等很久才会获得锁

### 一个线程中的多个流程能不能获取同一把锁？

#### 能

- 可重入锁：避免死锁

#### 不能

- 不可重入锁

### 多个线程能不能共享一把锁？

#### 能

- 共享锁

#### 不能

- 排它锁

## Lock

### ReentrantLock

### ReentrantReadWriteLock

#### state

- 高16位读锁个数

- 低16位写锁个数

#### ReadLock

- 获取的是共享锁

#### WriteLock

- 获取的是独占锁