#  对象创建过程

## 1、类加载机制


 虚拟机遇到new指令，首先进行类加载过程 
 
## 2、分配内存 

### 内存分配方式

-  指针碰撞 
  - 适用场景： Java堆内存规整 
  - 原理： 用过的内存放在一边，没用过的内存放在一边，中间有一个分界值指针，只需要向没用的内存方向移动对象大小的位置即可 
  - GC收集器： Serial、PartNew 
-  空闲列表
  -  适用场景： Java堆内存不规整 
  -  原理： 虚拟机维护一个列表，记录哪些内存是可用的，分配时找一块合适的内存分配给对象，并更新列表的记录 
  - GC收集器： CMS 

### 线程不安全

#### 解决办法

-  CAS+失败重试 
-  TLAB（Thread Local Allocation Buffer） 
  -  线程初始化时创建，线程私有，默认是Eden区域的1% 
  -  三个指针
    -  start ： 开始内存地址 
    -  top ： 分配指针，如果接近end，会重新申请一个TLAB 
    -  end ： 结束内存地址 
  -  缺点： 体积小，放不下大对象 

##  3、初始化0值 

##  4、设置对象头 

##  5、执行init方法 



#  对象的内存布局 

##  对象头 

-  哈希码，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等 
-  类型指针： 虚拟机通过这个来确定是哪个类的实例

##  实例数据 

 对象存储的真正的有效数据 

##  对齐填充 

 并不是必然存在，仅仅起着站位的作用， 对象是8字节的整倍数，通过对齐填充来补全 



#  对象的访问定位 

##  使用句柄 

 Java堆中划出一块内存作为句柄池，reference中存储的是对象的句柄地址，句柄中保存的是指向对象的地址 

-  优点 

 对象被移动时只会改变句柄中的实际的对象的地址，而reference本身的不需要修改 

-  缺点 

 增加了一次指针定位的开销 

##  直接访问 

 reference中存储的直接就是对象的地址 

-  优点 

 访问速度快，节省一次指针定位的时间开销  

-  缺点 

  对象移动会改变reference中存储的对象的地址值 



#  OutOfMemoryError异常 

##  Java堆溢出 

 参数：-XX:+HeapDumpOnOutOfMemoryError 

##  虚拟机栈和本地方法栈溢出 

 参数设定 

##  方法区和运行时常量池溢出 

 通过-XX:PermSIze和-XX:MaxPermSize限制方法区大小 

##  本机直接内存溢出 

 通过-XX:MaxDiretMemorySize指定 