## 锁分类

### 1、线程要不要锁住同步资源？

- 锁住：悲观锁，比如synchronized和Lock的实现类

- 不锁住：乐观锁，比如CAS算法

### 2、锁住同步资源失败，线程要不要阻塞？

#### 阻塞

#### 不阻塞

##### 自旋锁
  - 优点：避免线程切换的开销
  - 缺点：占用处理器时间，自旋时间越长占用CPU资源越多
  - 自旋次数可以通过（默认是10次，可以使用-XX:PreBlockSpin来更改）设置
  - 自旋使用-XX:+UseSpinning参数来开启
  - 常见锁形式
    - TicketLock
    - CLHlock
    - MCSlock

##### 适应性自旋锁

- 自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

- 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间

- 如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源

### 3、多个线程竞争锁是要不要排队？

#### 公平锁-排队

- 特点
  - 队列中的第一个线程能获取锁
  - 线程在队列中排队

- 优点
  - 等待锁的线程不会饿死始终会获取到锁

- 缺点
  - 除第一个线程外的线程都会阻塞，影响吞吐量
  - 唤醒阻塞线程的开销比非公平锁大

#### 非公平锁-先尝试插队，插队失败再排队

- 特点

多个线程直接参与锁的竞争，获取不到才加入等待队列

- 优点

可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程

- 缺点

处于等待队列中的线程可能会饿死，或者等很久才会获得锁

### 4、一个线程中的多个流程能不能获取同一把锁？

#### 能

- 可重入锁：避免死锁

#### 不能

- 不可重入锁

### 多个线程能不能共享一把锁？

#### 能

- 共享锁

#### 不能

- 排它锁

