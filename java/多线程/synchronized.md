## synchronized

### 各个锁状态下的对象头Mark Word分布

#### 无锁

- 锁标记位=01

- 是否偏向锁=0

- hashcode

- GC分代年龄

#### 偏向锁

- 锁标记位=01

- 是否偏向锁=1

- 偏向线程ID

- 偏向时间戳

#### 轻量级锁

- 锁标记位=00

- 指向栈中锁记录的指针

#### 重要级锁

- 锁标记位=10

- 指向互斥量（重量级锁）的指针

***大部分情况下锁状态只能升级不能降级***

#### 无锁

##### 概述

不锁住资源，多个线程只有一个能修改资源成功，其他资源会重试

#### 偏向锁

##### 概述

同一个线程执行同步资源时自动获取资源，降低获取锁的代价，强调是只有一个线程访问

对象头Mark Word（标记字段）中记录偏向的线程ID，后面直接检测线程ID来进入同步区域

##### 偏向锁获取过程

- 1、确认偏向锁标记位设置为1，锁标记位设置为01
- 2、标志位都正确的话，当前线程id与偏向线程id比较
    - 1、如果相等，进入同步代码
    - 2、如果不等，执行接下来的步骤
- 3、通过CAS竞争锁
    - 1、如果成功，设置偏向锁id为当前线程id，进入同步代码块
    - 2、如果失败，执行接下来的步骤

- 4、失败代表有竞争，暂停持有偏向锁的线程，这时如果偏向线程还活着，直接升级为轻量级锁

##### 偏向锁释放时机

遇到其他线程尝试竞争偏向锁时

##### 偏向锁释放流程

- 等待全局安全点（在这个时间点上没有字节码正在执行）

- 暂停拥有偏向锁的线程

- 判断锁对象是否处于被锁定状态

- 撤销偏向锁后恢复到未锁定或轻量级锁状态

通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态

#### 轻量级锁

##### 概述

多个线程竞争同步资源时，没有获取资源的线程自旋等待锁释放，不阻塞线程，这里强调的是两个线程

##### 加锁过程

- 1、将对象头中的Mark Word复制到线程栈帧的锁记录（Lock Record）中（官方称之为 Displaced Mark Word）

- 2、通过CAS将对象头的Mark Word更新为指向Lock Record的指针

- 3、将Lock Word里面的owner指针指向对象的Mark Word

- 4、如果成功，设置Mark Word中的锁标志位为00，这时就出于轻量级锁

- 5、如果失败，检查对象的Mark Word是否指向当前线程的栈帧，是直接进入同步块

##### 解锁过程

- 1、通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word

- 2、如果替换成功，整个同步过程就完成了

- 3、如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程

#### 重量级锁

##### 概述

多个线程同步资源时，没有获取资源的线程阻塞等待唤醒，这里强调的是三个及以上的线程

##### 实现

通过监视器来实现：monitor