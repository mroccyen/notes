# 垃圾回收

## GC做3件事

- 哪些区域需要回收？

- 什么时候回收？

- 怎么回收？

## 垃圾收集与算法

### 如何确定垃圾

#### 引用计数器

问题：循环引用，AB互相引用

#### 可达性分析

- 如果一个对象到GCRoots之间没有引用链相连，对象已经“死亡”

- GCRoots
  - 1.虚拟机栈（栈帧中的本地变量表）中引用的对象；
  - 2.方法区中的类静态属性引用的对象；
  - 3.方法区中常量引用的对象；
  - 4.本地方法栈中JNI（即一般说的Native方法）中引用的对象

### 垃圾收集算法

#### 标记清除

过程

- 1、标记回收对象

- 2、回收对象

缺点

- 效率低：循环遍历

- 内存碎片多：回收后造成内存不连续

#### 复制

过程

- 1、每次使用一半内存存储对象

- 2、回收时将存活对象复制到另一半内存中

- 3、清除当前一半内存区域空间

缺点

- 内存压缩一半

- 内存中存活对象较多时，复制的效率很低

#### 标记清理

过程

- 1、标记回收对象

- 2、移动存活对象到内存一端

- 3、回收对象

#### 分代收集算法

- 新生代采用复制算法：其实是标记清除+复制算法

- 老年代采用标记整理算法

## 四种引用

### 强引用

- 处于可达状态，不被JVM回收

- 内存泄漏的主要原因

### 软引用

- SoftReference类实现

- 内存不足时才会回收

### 弱引用

- WeakReference类实现

- 不管内存是否足够，JVM都会进行回收

### 虚引用

- PhantomReference 类实现

- 不能单独使用，必须和引用队列使用

- 主要用于对象被垃圾回收的状态跟踪

## 垃圾收集器

### Serial（新生代）

- 单线程

- 使用复制算法

- 垃圾回收时暂停所有工作线程（Stop the world）

- 是很多java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器 

### ParNew（新生代）

- 多线程

- 使用复制算法

- 垃圾回收时暂停所有工作线程（Stop the world）

- ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数

- 是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器 

### Parallel Scavenge（新生代）

- 多线程

- 使用复制算法

- 垃圾回收时暂停所有工作线程（Stop the world）

- 重点关注的是程序达到一个可控制的吞吐量 

- 自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别

### Serial Old（老年代）

- 单线程

- 使用标记-整理算法

- 垃圾回收时暂停所有工作线程（Stop the world）

- 主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器

### ParallelOld（老年代） 

- 多线程

- 使用标记-整理算法

- 垃圾回收时暂停所有工作线程（Stop the world）

### CMS（Concurrent mark sweep ）（老年代）

- 多线程

- 标记清除算法

- 主要目标牺牲吞吐量为代价获取最短垃圾回收停顿时间

- Java1.5启动阈值：68%空间使用率，Java1.6启动阈值：92%空间使用率，设置-XX:CMSInitialOccupancyFraction来修改

- 内存不足时出现Concurrent Mode Failure，并降级使用Serial Old进行收集，停顿时间增加

- 设置-XX:UseCMSCompactAtFullCollection开发参数用于开启内存碎片的合并整理

- CMS 默认启动的回收线程数是（CPU 数量+3）/ 4

#### 过程

1、初始标记

只是标记到达GCRoots的对象，暂停所有工作线程，速度很快

2、并发标记

GCRoots标记跟踪，和工作线程一起工作

3、重新标记

- 修正并发标记期间用户线程运行产生的标记变化

- 暂停所有线程

4、并发清除

 清除不可达GCRoots对象，和工作线程一起运行

#### 缺点

- 浮动垃圾：并发清除阶段用户线程运行会产生垃圾

- 产生内存碎片：采用标记清除算法的弊端

- 对CPU资源敏感

### G1（Garbage First）（老年代）

- jdk1.7出现

- 标记整理算法

#### 重要特征

- 并行与并发

G1 能充分利用 CPU、多核环境下的硬件优势来缩短 Stop-The-World 停顿时间。

不需要停顿 Java 线程，G1 可以通过并发的方式让 java 程序继续执行

- 分代收集

虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念

- 空间整合

与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的

- 可预测的停顿

G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内

#### 过程

1、初始标记

2、并发标记

3、最终标记

4、筛选回收

#### 优先列表

G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。

这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）

### ZGC（The Z Garbage Collector）

- jdk11新增的垃圾回收器