# 类加载机制

## 加载过程

### 1、加载

生成类的class对象，作为方法区中各种数据的入口

### 2、验证

确保class字节流中的信息符合虚拟机的规范

### 3、准备

- 为类变量分配空间和进行值的初始化

- 如果类变量被final修饰，在编译阶段会为生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 值赋给类变量 

### 4、解析

将常量池中的符号引用替换为直接引用

- 符号引用

- 直接引用

### 5、初始化

#### 执行类构造器<client>方法

<client>根据类变量和静态语句块生成

#### 不执行初始化的情况

- 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。

- 定义对象数组，不会触发该类的初始化。 

- 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类 

- 通过类名获取 Class 对象，不会触发类的初始化 

- 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化

- 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作 


## 类加载器

- 启动类加载器

- 扩展类加载器

- 应用程序类加载器

- 用户自定义加载器

### 双亲委派机制

#### 好处

- 避免类的重复加载

- 保证java的核心api不被串改

#### 不想用的时候怎么办

- 继承 ClassLoader，重写 loadClass() 方法

#### 想用但是不想打破

- 重写 ClassLoader 类中的 findClass() 方法